
## JQ

`JQ` est un outil puissant de ligne de commande conçu pour manipuler et transformer des données JSON de manière efficace. Que vous soyez un développeur, un analyste de données ou un utilisateur cherchant à explorer des données structurées au format JSON, JQ peut vous aider à accomplir vos tâches de manière rapide et flexible.

Grâce à son approche basée sur les pipes et les filtres, JQ peut être facilement intégré dans des flux de travail existants et combiné avec d'autres outils de ligne de commande. Il offre également une variété de fonctionnalités avancées telles que la gestion des tableaux, la manipulation des chaînes de caractères, les opérations arithmétiques et bien plus encore.

Pour installer JQ, lancez les commandes suivantes:

```bash
sudo apt-get update
sudo apt install jq
```

Téléchargez le fichier suivant en lançant la commande suivante dans votre terminal:

```bash
wget https://dst-de.s3.eu-west-3.amazonaws.com/bash_fr/people.json
```

Le fichier contient des renseignements sur des personnages de Star Wars. Il s'agit d'un fichier JSON qui a la même structure qu'un dictionnaire en Python. Le fichier sur lequel vous allez travailler possède une structure particulière: il s'agit d'un **tableau de documents**. Nous allons voir maintenant quelques fonctionnalités essentielles qu'il est possible d'utiliser avec JQ:

### 8.1 Les Filtres

Les filtres sont utilisés pour accéder à un champ spécifique dans un objet. Pour afficher le document avec `jq` il suffit de lancer la commande suivante:

```bash
cat people.json | jq .
```

Le `.` représente l'identité, ce qui veut dire que cela récupère l'objet en input et le ressort en output. Vous devriez avoir une sortie comme ci-dessous:

```json
[  
  {
    "birth_year": "19BBY",
    "created": "2014-12-09T13:50:51.644000Z",
    "edited": "2014-12-20T21:17:56.891000Z",
    "eye_color": "blue",
    "films": [
      "http://swapi.co/api/films/6/",
      "http://swapi.co/api/films/3/",
      "http://swapi.co/api/films/2/",
      "http://swapi.co/api/films/1/",
      "http://swapi.co/api/films/7/"
    ],
    "gender": "male",
    "hair_color": "blond",
    "height": "172",
    "homeworld": "http://swapi.co/api/planets/1/",
    "id": 1,
    "mass": "77",
    "name": "Luke Skywalker",
    "skin_color": "fair",
    "species": [
      "http://swapi.co/api/species/1/"
    ],
    "starships": [
      "http://swapi.co/api/starships/12/",
      "http://swapi.co/api/starships/22/"
    ],
    "url": "http://swapi.co/api/people/1/",
    "vehicles": [
      "http://swapi.co/api/vehicles/14/",
      "http://swapi.co/api/vehicles/30/"
    ]
  }
]
```

Nous voyons ici que nous avons un array de documents. Pour pouvoir travailler sur le fichier, il faudra obligatoirement avec l'identité ajouter le filtre `[]` qui permet de parcourir le contenu d'un tableau.

Il est possible de faire du slicing grâce à `jq` comme en Python.

> Affichez les 5 premiers documents présents dans le fichier.

Les filtres sont utilisés pour accéder à un champ spécifique dans un objet

```bash
cat people.json | jq .f
#### La virgule

Il est possible d'enchaîner les filtres en utilisant la `,`. Cet opérateur permet d'appliquer plusieurs filtres sur l'entrée standard fournie.

```bash
cat people.json | jq '.[].name, .[].height'
```

La sortie retournée sera l'ensemble de tous les noms puis de toutes les tailles disponibles dans le fichier.

#### Le pipe

Comme en bash, il est possible de récupérer la sortie d'une commande pour la passer dans un second filtre grâce au `|`. Cela nous permettra de simplifier l'écriture lors de l'enchaînement de filtres.

```bash
cat people.json | jq '.[] | .birth_year'
```

### 8.2 Les Constructeurs

Avec `JQ` il est possible de construire des objets de type tableaux ou document et d'y stocker les résultats d'une requête. Il s'agit d'un processus très pratique pour créer de nouveaux documents rapidement sans dénaturer l'original.

Créons des tableaux contenant les informations clés de chaque personnage:

```bash
cat people.json | jq .[] | jq '[.name, .birth_year, .mass, .height]'
```

La construction d'un document est légèrement différente, il suffit de mettre des accolades `{}`:

```bash
cat people.json | jq .[] | jq '{name, height, films: .films[]}'
```

Si on veut récupérer des champ qui se trouvent au premier niveau d'indentation, on peut juste spécifier le nom du champs. Cela prendra le nom du champ du document initial et le reportera dans le nouveau document qui sera créé. Par contre pour récupérer des informations contenues dans un tableau, il faut dans ce cas spécifier le nouveau nom du champ ainsi que sa valeur. Pour récupérer les valeurs d'un tableau, il ne faut pas oublier de mettre les `[]` après le nom du champ.

> Construisez un document composé des 10 premiers personnages et contenant les champs suivants: {name, birth_year, mass, height, species, details: [homeworld, vehicles, starships]}

La sortie devrait ressembler à quelque chose comme ceci:

```shell
{
  "name": "Luke Skywalker",
  "birth_year": "19BBY",
  "mass": "77",
  "species": "http://swapi.co/api/species/1/",
  "details": [
    "http://swapi.co/api/planets/1/",
    [
      "http://swapi.co/api/vehicles/14/",
      "http://swapi.co/api/vehicles/30/"
    ],
    "http://swapi.co/api/starships/12/",
    "http://swapi.co/api/starships/22/"
  ]
}

```

```bash
cat people.json | jq '.[0:10] | .[] | {name, birth_year, mass, species : .species[]?, details: [.homeworld, .vehicles, (.starship[]?)]}'
```

Le `?` dit à `jq` : “si c’est null, ignore au lieu d’exploser”.
### 8.3 Opérateurs et fonctions intégrées

Il existe en `JQ` un ensemble d'opérateurs et de fonctions intégrées. On retrouve les opérateurs mathématiques d'`addition`, de `soustraction`, de `multiplication`, et de `division`. Ces derniers permettent de réaliser des opérations entre un scalaire et un document ou alors entre plusieurs documents.

#### Addition

Cet opérateur agit de manière différente en fonction des types d'entrées que l'on va lui donner.

- Si les entrées sont des `nombres`, alors le résultat obtenu sera une addition classique.

```bash
cat people.json | jq '.[0].id + .[1].id'
```

- Si les entrées sont des `tableaux`, alors le résultat sera la concaténation de ces derniers.

```bash
cat people.json | jq '.[0].species + .[1].species'
```

- Si les entrées sont des `strings`, on obtient une chaîne concaténée.

```bash
cat people.json | jq '.[0].name + .[1].name'
```

- Si les entrées sont des `documents`, le résultat sera une jointure.

```bash
cat people.json | jq '.[] | {name, birth_year, mass} + {name, height}'
```

Si des documents ont les mêmes noms de clés, alors la valeur qui se trouve à droite du `+` sera conservée dans le résultat.

```bash
cat people.json | jq '.[0] + .[1]'
```

Dans l'exemple précédent, nous avons juste additionné les documents mais comme ce sont exactement les mêmes, on ne garde uniquement les valeurs du document se situant à droite du `+`.

#### Soustraction

Grâce à cet opérateur, il est possible de faire une soustraction entre deux nombres mais aussi de retirer des valeurs présentes dans un tableau. Attention à la syntaxe qui spécifie qu'il est possible de supprimer des occurrences uniquement entre des tableaux.

```bash
cat people.json | jq '.[0].films - ["http://swapi.co/api/films/6/", "http://swapi.co/api/films/7/"]'
```

#### Multiplication

La multiplication avec `JQ` possède elle aussi plusieurs propriétés particulières. Premièrement, il est possible de faire la multiplication classique de deux nombres entiers. Ensuite, il est aussi possible de multiplier un `nombre` avec un `string`. Cette dernière aura pour résultat de concaténer des strings un certain nombre de fois.

```bash
cat people.json | jq '.[10].id * 15'

cat people.json | jq '.[0].name * 3'
```

La sortie de la commande précédente devrait être:

```shell
165
"Luke SkywalkerLuke SkywalkerLuke Skywalker"
```

#### Division

La division a un effet très pratique sur les chaînes de caractères. Il est certes possible de diviser des nombres entre eux (sauf évidemment la division par 0), mais il est aussi possible de séparer une phrase avec un séparateur. Dans l'exemple suivant, nous allons séparer une chaîne de caractères par un séparateur qui est lui-même une chaîne de caractères :

```bash
cat people.json | jq '.[0].name / "e"'
```

Le résultat est le suivant:

```bash
[
  "Luk",
  " Skywalk",
  "r"
]

```

On remarque bien que la chaîne de caractères initiale `Luke Skywalker` a été séparée en 3 parties en fonction du séparateur `e`.

#### Fonction intégrée Group By

La fonction `group_by` permet de regrouper, dans différents tableaux, des documents qui ont la même clé.

```bash
cat people.json | jq 'group_by(.eye_color)'
```

La sortie est un tableau composé de plusieurs tableaux regroupant les documents qui ont les mêmes modalités sur l'attribut `eye_color`. Il est possible de compter le nombre de modalités de l'attribut `eye_color` ainsi que d'en calculer le nombre d'occurrences:

```bash
cat people.json | jq 'group_by(.eye_color)[] | {gender: .[0].eye_color, count: length}'
```

Vous devriez obtenir la sortie suivante:

```bash
{
  "eye_color": "black",
  "count": 10
}
{
  "eye_color": "blue",
  "count": 19
}
{
  "eye_color": "blue-gray",
  "count": 1
}
{
  "eye_color": "brown",
  "count": 20
}
{
  "eye_color": "dark",
  "count": 1
}
{
  "eye_color": "gold",
  "count": 1
}
{
  "eye_color": "green, yellow",
  "count": 1
}
{
  "eye_color": "hazel",
  "count": 2
}
{
  "eye_color": "orange",
  "count": 8
}
{
  "eye_color": "pink",
  "count": 1
}
{
  "eye_color": "red",
  "count": 5
}
{
  "eye_color": "red, blue",
  "count": 1
}
{
  "eye_color": "unknown",
  "count": 1
}
{
  "eye_color": "white",
  "count": 1
}
{
  "eye_color": "yellow",
  "count": 11
}

```

Nous avons ici utiliser la fonction intégrée `length` qui permet de retourner la longueur d'un objet. Dans notre cas, la fonction va s'appliquer à tous les arrays et donc compter le nombre de documents se trouvant dedans.

Focalisons nous sur la commande `{gender: .[0].eye_color}`. Précédemment, nous avons un objet qui comporte une liste de plusieurs listes. Dans chacune de ces listes, nous avons tous les documents qui ont la même `eye_color`, dans notre cas, il y a 15 listes différentes car il y a 15 `eye_color` différentes. Si nous retirons le `0` cela va constuire 83 documents qui contiendront les couleurs des yeux et le compte par couleur d'yeux. Testons la commande sans mettre le `0`

```bash
cat people.json | jq 'group_by(.eye_color)[] | {gender: .[].eye_color, count: length}'
```

Voici la sortie qui est tronquée:

```shell
{
  "gender": "black",
  "count": 10
}
{
  "gender": "black",
  "count": 10
}
{
  "gender": "black",
  "count": 10
}
{
  "gender": "black",
  "count": 10
}
{
  "gender": "black",
  "count": 10
}
{
  "gender": "black",
  "count": 10
}
{
  "gender": "black",
  "count": 10
}
{
  "gender": "black",
  "count": 10
}
{
  "gender": "black",
  "count": 10
}
{
  "gender": "black",
  "count": 10
}
{
  "gender": "blue",
  "count": 19
}
{
  "gender": "blue",
  "count": 19
}
{
  "gender": "blue",
  "count": 19
}
{
  "gender": "blue",
  "count": 19
}

```

Donc le `0` nous permet de récupérer un seul élément par groupe de couleur d'yeux.

Il existe encore de nombreuses fonctions et opérateurs dans `JQ`. Cet outil est très puissant et permet d'accélérer les phases de transformation lors d'un pipeline d'Extraction, Transformation et Chargement de données, appelé aussi `ETL`. Dans la prochaine section, nous conclurons le module et vous trouverez également l'évaluation.